# 値オブジェクト

### 値オブジェクトとは
値オブジェクトとは、特定の値をオブジェクトとして扱い、その値に依存した操作や等価性の判断を一元管理するもの   

### 性質
値のオブジェクトの性質は以下のように定義されている
- 不変である
- 交換が可能である
- 等価性によって比較される

## 不変である とは
オブジェクトが生成された時点で値が確定し、セッターなどで途中更新されない   
値オブジェクトはコンストラクタなどで生成されることが一般的

↓以下は変更されているとはならない（変更ではなく代入）
```go
// リスト1-1
text := "こんにちは"
fmt.Println(text)   // こんにちは
text = "さようなら"
fmt.Println(text)   // さようなら
```

↓以下は変更されていると言える（text変数にChangeメソッドは存在するはずがないが疑似的に値を変更するを再現した処理）
```go
// リスト1-2
text := "こんにちは"
// ここで本来存在しないChangeメソッドを疑似的に使い、値が変更される状況を再現しています
text.Change("さようなら")
fmt.Println(text)    // 実際にはさようならにはなりませんが、仮に変更できたら「さようなら」になります
```

↓リスト1-2をより分かりやすく値を変更するを再現した処理
```go
// リスト1-3
"こんにちは".Change("さようなら")
fmt.Println("こんにちは")   // さようならにはならない
```

↓実際の現場で見られる実装（リスト1-3と同じである）
```go
fullName := fullname.NewFullName("山田", "太郎")
fullName.Change("花子")
```

## 交換が可能である とは
値オブジェクトは不変である   
不変の性質をもつ値はそれ自体を変更できない   
リスト1-3のように値を直接変更するのはなく代入によって値の変更を表現する   

```go
// リスト2-1: 普段何気なくやっている値の変更
name := "山田"
name = "佐藤"

money := 1000
money = 2000

```

```go
// リスト2-2: 値オブジェクトの変更方法
fullname := fullName.NewFullName("山田", "太郎")
// 値オブジェクトの性質により、値を変更するのではなく新しいインスタンスを生成し直す
fullname = fullName.NewFullName("佐藤", "花子")
```
リスト2-2は値オブジェクトが不変であるため代入以外の交換方法では表現できなくなっている

## 等価性によって比較される とは
等価性で比較できることのメリットは以下2つある
1. 属性が増えても修正範囲が1カ所にとどまる
2. 不自然な比較コードから解放される

### 属性が増えても修正範囲が1カ所にとどまる
等価比較メソッドを定義していない場合、以下の比較処理が生まれる
```go
// リスト3-1
if fullNameA.FirstName == fullNameB.FirstName &&
    fullNameA.LastName == fullNameB.LastName {
        // 同姓同名は存在できないとかの処理
    }
```
リスト3-1で運用後、ユーザー名にミドルネームを新たに追加するという仕様が入った場合はリスト3-1を以下のように修正します
```go
// リスト3-2
if fullNameA.FirstName == fullNameB.FirstName &&
    fullNameA.MiddleName == fullNameB.MiddleName &&
    fullNameA.LastName == fullNameB.LastName {
        // 同姓同名は存在できないとかの処理
    }
```
これ自体の修正は容易だが、同じ条件判定を行っている箇所を漏れなく探し修正する必要がある   
この「漏れなく」という慎重さを求める作業は開発者を疲弊させる   
以下の比較メソッドを用意することで値オブジェクトに追加仕様が入っても修正箇所が1カ所にとどまり開発者を疲弊させない
```go
// リスト3-3: 等価性を判断するためのEqualsメソッド
func (fullName *FullName) Equals(otherFullName FullName) bool {
    // reflect.DeepEqualは複数のフィールドを再帰的に比較するために使用している
	return reflect.DeepEqual(fullName.FirstName, otherFullName.FirstName) && 
        reflect.DeepEqual(fullName.LastName, otherFullName.LastName)
        // 属性が増えたらここに追加するだけで「漏れなく」に対応できる
}
```

### 不自然な比較コードから解放される
もしリスト3-1のようなコードが値オブジェクト外で記述されていたら不自然になる   
以下は値で置き換えた場合
```go
// リスト3-4: 不自然な比較例
if "山田".value == "佐藤".value {
    // ここでの問題は、文字列やプリミティブな型に対してvalueという冗長なメソッドを使っている
    // 値そのものを直接比較する方が自然
}
```
言語化するなら「値の値(value)を取り出す」というかなり不自然なコードになる   
値オブジェクトの場合、オブジェクトゆえにこの不自然さに気づきずらいが一度値に置き換えるとその不自然さに気づける

値オブジェクトはどこまでいっても値である   
オブジェクトの値を取り出して比較するのではなく、値と同じようにオブジェクト同士が比較できるようにすることでこの不自然さを解消できる

```go
// リスト3-5: Equalsメソッドを使用したサンプル
fullnameA := fullName.NewFullName("山田", "太郎")
fullnameB := fullName.NewFullName("佐藤", "花子")

if fullNameA.Equals(fullNameB) {
    // 同姓同名は存在できないとかの処理
}
```

## サンプルコード
値オブジェクト → /app/internal/domain/model/*   
実行サンプル → /app/cmd/main.go